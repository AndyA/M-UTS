!to "m-uts.rom", plain

* = $8000

!addr osfind = $ffce
!addr osgbpb = $ffd1
!addr osbput = $ffd4
!addr osbget = $ffd7
!addr osargs = $ffda
!addr osfile = $ffdd
!addr osrdch = $ffe0
!addr osasci = $ffe3
!addr osnewl = $ffe7
!addr oswrch = $ffee
!addr osword = $fff1
!addr osbyte = $fff4
!addr oscli = $fff7
!addr irq2v = $206
!addr irq1v = $204
!addr brkv = $202
!addr userv = $200
!addr uptv = $222
!addr evntv = $220
!addr fscv = $21e
!addr findv = $21c
!addr gbpbv = $21a
!addr bputv = $218
!addr bgetv = $216
!addr argsv = $214
!addr filev = $212
!addr rdchv = $210
!addr wrchv = $20e
!addr wordv = $20c
!addr bytev = $20a
!addr cliv = $208

!addr ptr0 = $a8

!addr acc0 = $aa
!addr acc1 = $ac

!addr cmd_offset = $ae

!addr cmdjmp = $b0
!addr cmdhelp = $b2

!addr acc2 = $b4
!addr acc3 = $b6

!addr hex_pfx = $b8

!addr cmdline = $f2
!addr cur_rom = $f4
!addr err = $fd
!addr esc_flag = $ff

!addr stack = $0100

!addr vars = $0300

!addr regs = $0400
!addr reg_a = regs + ('A' - 'A') * 2
!addr reg_pc = regs + ('I' - 'A') * 2
!addr reg_x = regs + ('X' - 'A') * 2
!addr reg_y = regs + ('Y' - 'A') * 2
!addr reg_p = regs + ('P' - 'A') * 2
!addr reg_s = regs + ('S' - 'A') * 2

n_breakpoints = 16
!addr breakpoints = $0500

!addr base_addr = $0600
!addr rom_sel   = $0602
!addr prompt    = $0603

cmd_line_len = 160
!addr cmd_line = $0700

!addr brk_cmd = cmd_line + cmd_line_len

!addr rom_private = $0df0

!addr x_present = $a000
!addr x_assemble = $a001
!addr x_eval = $a004

key_left = $88
key_right = $89
key_down = $8a
key_up = $8b

key_sh_left = $a0
key_sh_right = $a1
key_sh_down = $a2
key_sh_up = $a3

case_mask = $df

!macro inc16 addr {
  inc addr
  bne +
  inc addr + 1
+
}

; FIXME reproduces bug in original code
!macro dec16bug .addr {
  lda .addr + 1
  bne +
  dec .addr + 1
+ dec .addr
}

!macro dec16 .addr {
  lda .addr
  bne +
  dec .addr + 1
+ dec .addr
}

!macro adc16 .dst, .lhs, .rhs {
  lda .lhs
  adc .rhs
  sta .dst
  lda .lhs + 1
  adc .rhs + 1
  sta .dst + 1
}

!macro sbc16 .dst, .lhs, .rhs {
  lda .lhs
  sbc .rhs
  sta .dst
  lda .lhs + 1
  sbc .rhs + 1
  sta .dst + 1
}

!macro cmp16 .lhs, .rhs {
  lda .lhs
  cmp .rhs
  lda .lhs + 1
  sbc .rhs + 1
}

!macro cmz16 .reg {
  lda .reg
  ora .reg + 1
}

!macro mov16 .dst, .src {
  lda .src
  sta .dst
  lda .src + 1
  sta .dst + 1
}

!macro mov16i .dst, .addr {
  lda #< .addr
  sta .dst
  lda #> .addr
  sta .dst + 1
}

!macro mov16z .dst {
  lda #0
  sta .dst
  sta .dst + 1
}

!macro stxy .dst {
  stx .dst
  sty .dst + 1
}

; Add A to 16 bit reg
!macro adca16 .dst {
  adc .dst
  sta .dst
  bcc +
  inc .dst + 1
+
}

!macro asl16 .reg {
  asl .reg
  rol .reg + 1
}

!macro rol16 .reg {
  rol .reg
  rol .reg + 1
}

!macro push16 .addr {
  lda .addr
  pha
  lda .addr + 1
  pha
}

!macro pop16 .addr {
  pla
  sta .addr + 1
  pla
  sta .addr
}

; For assembler tables

!macro mnem .c1, .c2, .c3, .bits, .mask {
  !set .cc = ((.c1 - $3f) << 11) | ((.c2 - $3f) << 6) | ((.c3 - $3f) << 1)
  !byte < .cc, > .cc, .bits, .mask
}

!macro ilen4 .l0, .l1, .l2, .l3 {
  !byte (.l0 << 6) | (.l1 << 4) | (.l2 << 2) | (.l3 << 0)
}

!macro ilen .l0, .l1, .l2, .l3, .l4, .l5, .l6, .l7, .l8, .l9, .l10, .l11, .l12, .l13, .l14, .l15 {
  +ilen4 .l0, .l1, .l2, .l3
  +ilen4 .l4, .l5, .l6, .l7
  +ilen4 .l8, .l9, .l10, .l11
  +ilen4 .l12, .l13, .l14, .l15
}

rom_language        jmp language
rom_service         jmp service

                    ; ROM type
rom_type            !byte %11000010
                    ; Copyright offset. Points to 0 before copyright
copyright_offset    !byte copyright - rom_language - 1
                    ; Version
                    !byte 2 
title               !text "M-UTS", 0
version             !text "1.60", 0
copyright           !text "(C) AIAA 1984", 0

; Jump table to expose well known addresses to optional upper half of ROM

j_prstr             jmp prstr
j_throw             jmp throw
j_newline           jmp newline
j_check_escape      jmp check_escape
j_hexbyte           jmp hexbyte
j_hexbyte_space     jmp hexbyte_space
j_radix_out         jmp radix_out
j_getch             jmp getch
j_skip_space        jmp skip_space
j_eval              jmp eval
j_eval_byte         jmp eval_byte
j_check_eol         jmp check_eol
j_parse_bytestring  jmp parse_bytes
j_try_poke          jmp try_poke
j_acc0_to_tmp0      jmp acc0_to_acc2
j_unget             jmp unget
j_x0                jmp 0
j_x1                jmp 0

; Command lookup table. Each entry is the command name with the top bit of
; the last char set followed by abs pointers to the code and help text for
; that command.

!set next_token = $80

!macro cmd ~.token {
  .token = next_token
  !set next_token = next_token + 1
}

cmd_table           +cmd ~tok_assemble
                    !text "ASSEMBL", 'E' + $80
                    !word c_assemble, h_assemble 

                    +cmd ~tok_base
                    !text "BAS", 'E' + $80
                    !word c_base, h_base 

                    +cmd ~tok_calc
                    !text "CAL", 'C' + $80
                    !word c_calc, h_calc 

                    +cmd ~tok_change
                    !text "CHANG", 'E' + $80
                    !word c_change, h_change 

                    +cmd ~tok_clr
                    !text "CL", 'R' + $80
                    !word c_clr, h_clr 

                    +cmd ~tok_dis
                    !text "DI", 'S' + $80
                    !word c_dis, h_dis 

                    +cmd ~tok_edit
                    !text "EDI", 'T' + $80
                    !word c_edit, h_edit 

                    +cmd ~tok_flist
                    !text "FLIS", 'T' + $80
                    !word c_flist, h_flist 

                    +cmd ~tok_form
                    !text "FOR", 'M' + $80
                    !word c_form, h_form 

                    +cmd ~tok_find
                    !text "FIN", 'D' + $80
                    !word c_find, h_find 

                    +cmd ~tok_get
                    !text "GE", 'T' + $80
                    !word c_get, h_get 

                    +cmd ~tok_go
                    !text "G", 'O' + $80
                    !word c_go, h_go 

                    +cmd ~tok_look
                    !text "LOO", 'K' + $80
                    !word c_look, h_look 

                    +cmd ~tok_mem
                    !text "ME", 'M' + $80
                    !word c_mem, h_mem 

                    +cmd ~tok_mode
                    !text "MOD", 'E' + $80
                    !word c_mode, h_mode 

                    +cmd ~tok_monitor
                    !text "MONITO", 'R' + $80
                    !word c_monitor, h_monitor 
 
                    +cmd ~tok_move
                    !text "MOV", 'E' + $80
                    !word c_move, h_move 
 
                    +cmd ~tok_onbrk
                    !text "ONBR", 'K' + $80
                    !word c_onbrk, h_onbrk 
 
                    +cmd ~tok_put
                    !text "PU", 'T' + $80
                    !word c_put, h_put 
 
                    +cmd ~tok_regs
                    !text "REG", 'S' + $80
                    !word c_regs, h_regs 
 
                    +cmd ~tok_same
                    !text "SAM", 'E' + $80
                    !word c_same, h_same 
 
                    +cmd ~tok_select
                    !text "SELEC", 'T' + $80
                    !word c_select, h_select 
 
                    +cmd ~tok_set
                    !text "SE", 'T' + $80
                    !word c_set, h_set 
 
                    +cmd ~tok_step
                    !text "STE", 'P' + $80
                    !word c_step, h_step 
 
                    +cmd ~tok_vdu
                    !text "VD", 'U' + $80
                    !word c_vdu, h_vdu 
 
                    +cmd ~tok_verify
                    !text "VERIF", 'Y' + $80
                    !word c_verify, h_verify 
 
                    +cmd ~tok_where
                    !text "WHER", 'E' + $80
                    !word c_where, h_where 

; The command table is also used for operator names

                    ; AND
op_and              +cmd ~tok_and
                    !text "AN", 'D' + $80
                    !word 0, 0 
 
                    ; OR
                    +cmd ~tok_or
                    !text "O", 'R' + $80
                    !word 0, 0 
 
                    ; EOR
                    +cmd ~tok_eor
                    !text "EO", 'R' + $80
                    !word 0, 0 
 
                    ; NOT
                    +cmd ~tok_not
                    !text "NO", 'T' + $80
                    !word 0, 0 
                    !text 0

; Help text per command. Top bit of last char of each entry is set

help_table                    
h_assemble          !text "<fsp> <fsp", '>' + $80
h_base              !text "<addr", '>' + $80
h_calc              !text "<expr", '>' + $80
h_change            !text "<addr> <byte string", '>' + $80
h_clr               !text "(<addr>", ')' + $80
h_dis               !text "<strt>(..<end>) (H<prefix>"
                    !text ") (P,L", ')' + $80
h_edit              !text "<addr", '>' + $80
h_flist             !text "(<number>", ')' + $80
h_form              !text "<tracks> (<drv>", ')' + $80
h_find              !text "<strt>(..<end>) <byte string", '>' + $80
h_get               !text "<track> (<drv>", ')' + $80
h_go                !text "<addr> (<A>) (<X>) (<Y>", ')' + $80
h_look              !text "<addr> (H<prefix>", ')' + $80
h_mem               !text "<strt>(..<end>) (P,L", ')' + $80
h_mode              !text "<mode", '>' + $80
h_monitor           !text ' ' + $80
h_move              !text "(>) <src> <dest> <len> (<addr>", ')' + $80
h_onbrk             !text "<command line", '>' + $80
h_put               !text "<track> (<drv>", ')' + $80
h_regs              !text ' ' + $80
h_same              !text "<addr> <addr> <len", '>' + $80
h_select            !text "<rom number", '>' + $80
h_set               !text "<addr", '>' + $80
h_step              !text "<addr> (H<prefix>) (P,L", ')' + $80
h_vdu               !text "<byte string", '>' + $80
h_verify            !text "(<drv>", ')' + $80
h_where             !text ' ' + $80
                    !text 0

; The ASSEMBLE command checks the upper half of the ROM for a possible
; assembler implementation

c_assemble          lda x_present
                    cmp #$ff
                    bne throw_noasm
                    jmp x_assemble
                    
throw_noasm         jsr throw
                    !text $a0, "No assembler", 0

; Attempt to execute a command

dispatch_cmd        +push16 cmdline
                    jsr lookup_command
                    bpl dispatch_done
                    jsr getch
                    and #case_mask
                    cmp #'A'
                    bcc +
                    cmp #'Z' + 1
                    bcs +
dispatch_done       +pop16 cmdline
                    sec
                    rts
                    
+                   jsr unget
                    +cmz16 cmdjmp
                    beq dispatch_done
                    pla
                    pla
                    jsr call_cmd
                    clc
                    rts
                    
call_cmd            jmp (cmdjmp)

; Print M-UTS with version

pr_muts             jsr prstr
                    !text "M-UTS 1.60", 13, 0
                    rts

; Print a banner

pr_banner           jsr newline
                    jsr pr_muts
                    jsr prstr
                    !text -2, "MONITOR", 13, 0
                    rts

; Output a character counting it in acc2

oswrch_counted      inc acc2
                    jmp oswrch
                    
show_help           jsr newline
                    jsr pr_muts
                    jsr newline
                    ldx #0
                    ldy #0
                    +mov16i acc0, help_table
--                  lda #2
                    sta acc2
                    tya
                    pha
                    jsr prstr
                    !text -2, 0
                    pla
                    tay
-                   lda cmd_table, y
                    iny
                    pha
                    and #$7f
                    jsr oswrch_counted
                    pla
                    bpl -
                    iny
                    iny
                    iny
                    iny
                    lda #' '
                    jsr oswrch_counted
-                   lda (acc0, x)
                    +inc16 acc0
                    pha
                    and #$7f
                    jsr oswrch_counted
                    pla
                    bpl -
                    jsr check_escape
                    ; pad with spaces to 40 cols
                    lda #' '
                    ldx acc2
-                   jsr oswrch_counted
                    inx
                    cpx #40
                    bcc -
                    ldx #0
                    lda (acc0, x)
                    bne --
                    jmp newline
                    
prstr               pla
                    sta ptr0
                    pla
                    sta ptr0 + 1
                    ldy #0
-                   +inc16 ptr0
                    lda (ptr0), y
                    beq ++
                    bpl +
                    tax
                    lda #' '
--                  jsr oswrch
                    inx
                    bne --
                    beq -
+                   jsr osasci
                    bne -
++                  lda ptr0 + 1
                    pha
                    lda ptr0
                    pha
                    rts
                    
throw               jsr reset_terminal
                    pla
                    sta ptr0
                    pla
                    sta ptr0 + 1
                    ldy #0
                    sty stack
-                   iny
                    lda (ptr0), y
                    sta stack, y
                    bne -
                    jmp stack
                    
newline             jsr osnewl
check_escape        bit esc_flag
                    bmi throw_escape
                    rts
                    
throw_escape        jsr throw
                    !text 17, "Escape", 0
                    
hexbyte             pha
                    ror
                    ror
                    ror
                    ror
                    jsr hexnybble
                    pla
hexnybble           pha
                    and #$0f
                    cmp #10
                    sed
                    adc #'0'
                    cld
-                   jsr oswrch
                    pla
                    rts
                    
hexbyte_space       jsr hexbyte
                    pha
                    lda #' '
                    bne -
                    
radix_out           sta acc1
                    lda #0
                    pha
-                   lda #0
                    ldy #16
--                  +asl16 acc0
                    rol
                    cmp acc1
                    bcc +
                    sbc acc1
                    inc acc0
+                   dey
                    bne --
                    cmp #10
                    bcc +
                    adc #'A' - '9' - 2
+                   adc #'0'
                    pha
                    dex
                    +cmz16 acc0
                    bne -
                    lda #' '
-                   dex
                    bmi +
                    jsr oswrch
                    bne -
+
-                   pla
                    jsr oswrch
                    bne -
                    rts
                    
getch               ldy #0
                    lda (cmdline), y
                    +inc16 cmdline
                    rts
                    
skip_space          jsr getch
                    cmp #' '
                    beq skip_space
                    cmp #13
                    rts
                    
to_upper            pha
                    and #case_mask
                    cmp #'A'
                    bcc +
                    cmp #'Z' + 1
                    bcs +
                    pla
                    and #case_mask
                    rts

+                   pla
                    rts
                    
radix_parse         sta acc1
                    +push16 ptr0
                    +mov16z acc0
                    jsr skip_space
-                   jsr to_upper
                    sec
                    sbc #'0'
                    bcc ++
                    cmp #10
                    bcc +
                    cmp #'A' - '9' - 1 + 10
                    bcc ++
                    sbc #'A' - '9' - 1
+                   cmp acc1
                    bcs ++
                    pha
                    +mov16 ptr0, acc0
                    +mov16z acc0
                    ldx #5
                    lda acc1
--                  ror
                    bcc +
                    pha
                    clc
                    +adc16 acc0, acc0, ptr0
                    pla
+                   +asl16 ptr0
                    dex
                    bne --
                    clc
                    pla
                    adc acc0
                    sta acc0
                    bcc +
                    inc acc0 + 1
+                   lda (cmdline), y
                    iny
                    bne -
++                  +pop16 ptr0
                    tya
                    clc
                    adc cmdline
                    sta cmdline
                    bcc +
                    inc cmdline + 1
+                   jsr unget
                    dey
                    rts

; Expression evaluator. This has a longstanding bug (since 1984): it
; right-recurses - so it evaluates A - B - C as A - (B - C) rather
; than (A - B) - C. I knew about it at the time but, for some reason,
; didn't fix it.

eval_atom           tsx           ; check SP
                    cpx #$80      ; could just be a BMI
                    bcs +
                    jsr throw
                    !text $a1, "Formula too complex", 0
                    
+                   jsr lookup_token
                    ; - = negate term
                    cmp #'-'
                    bne +
                    jsr eval_atom
                    lda #0
                    sec
                    sbc acc0
                    sta acc0
                    lda #0
                    sbc acc0 + 1
                    sta acc0 + 1
                    rts
                    
                    ; + = skipped
+                   cmp #'+'
                    beq eval_atom

                    ; ? = peek
                    cmp #'?'
                    bne +
                    jsr eval_atom
                    ldy #0
                    lda (acc0), y
                    sta acc0
                    sty acc0 + 1
                    rts
                    
                    ; ! = word peek
+                   cmp #'!'
                    bne +
                    jsr eval_atom
                    ldy #0
                    lda (acc0), y
                    tax
                    iny
                    lda (acc0), y
                    sta acc0 + 1
                    stx acc0
                    rts
                    
                    ; @ = set radix
+                   cmp #'@'
                    bne +
                    lda #10
                    sta acc1
                    jsr eval_d
                    lda acc0
                    cmp #2
                    bcc throw_bad_base
                    cmp #35
                    bcs throw_bad_base
                    sta acc1
                    jsr skip_comma
                    jmp eval_atom
                    
                    ; 9e = NOT
+                   cmp #tok_not
                    bne +
                    jsr eval_atom
                    lda acc0
                    eor #$ff
                    sta acc0
                    lda acc0 + 1
                    eor #$ff
                    sta acc0 + 1
-                   rts
                    
throw_bad_base      jsr throw
                    !text $a2, "Bad base", 0
                    
                    ; ( = nested
+                   cmp #'('
                    beq +
                    ; { = nested
                    cmp #'{'
                    beq +
                    ; [ = nested
                    cmp #'['
                    bne ++
+                   cmp #'[' - 1
                    adc #1
                    pha
                    jsr eval_hex
                    jsr skip_space
                    sta ptr0
                    pla
                    cmp ptr0
                    beq -
                    jsr throw
                    !text $a3, "Missing bracket", 0

                    ; ' = char const
++                  cmp #"'"
                    bne +
                    jsr getch
                    sta acc0
                    sty acc0 + 1
                    jsr getch
                    cmp #"'"
                    bne syn_err_jump
                    rts
                    
                    ; : = variable lookup
+                   cmp #':'
                    bne ++
                    jsr getch
                    and #case_mask
                    cmp #'A'
                    bcs +

throw_badvar        jsr throw
                    !text $a4, "Bad variable", 0

+                   cmp #'Z' + 1
                    bcs throw_badvar
                    asl
                    tax
                    lda vars + '?' * 2, x
                    sta acc0
                    lda vars + '?' * 2 + 1, x
                    sta acc0 + 1
                    rts

; The top 8k of the ROM can optionally contain an assembler which
; handles the ASSEMBLE command and can also extend the expression
; evaluator by parsing additional atoms here.

++                  ldx x_present
                    cpx #$ff
                    bne +
                    jmp x_eval
                    
+                   jsr unget
                    lda acc1
                    jsr radix_parse
                    bmi syn_err_jump
                    jsr skip_space
                    jsr to_upper
                    ; k suffix?
                    cmp #'K'
                    bne +
                    ; multiply by 1024
                    lda acc0
                    asl
                    asl
                    sta acc0 + 1
                    lda #0
                    sta acc0
                    rts
                    
+                   jmp unget
                    
syn_err_jump        jmp syntax_error
                    
eval_b              jsr eval_atom
                    jsr skip_space
                    ; * = multiply
                    cmp #'*'
                    bne +
                    +push16 acc0
                    jsr eval_b
                    +pop16 acc2
                    +mov16z ptr0
                    ldy #16 ; bits
-                   lsr acc0 + 1
                    ror acc0
                    bcc ++
                    clc
                    +adc16 ptr0, acc2, ptr0
++                  +asl16 acc2
                    dey
                    bne -
                    jmp ++
                    
                    ; / = divide
+                   cmp #'/'
                    bne +
                    jsr divmod
                    lda acc2
                    ldx acc2 + 1
                    jmp +++
                    
                    ; % = mod
+                   cmp #'%'
                    bne +
                    jsr divmod
++                  lda ptr0
                    ldx ptr0 + 1
+++                 sta acc0
                    stx acc0 + 1
                    rts
                    
+                   jmp unget
                    
eval_c              jsr eval_b
                    jsr skip_space
                    ; + = add
                    cmp #'+'
                    bne +
                    lda acc0 + 1
                    pha
                    lda acc0
                    pha
                    jsr eval_c
                    clc
                    pla
                    adc acc0
                    sta acc0
                    pla
                    adc acc0 + 1
                    sta acc0 + 1
                    rts
                    
                    ; - = subtract
+                   cmp #'-'
                    bne +
                    lda acc0 + 1
                    pha
                    lda acc0
                    pha
                    jsr eval_c
                    sec
                    pla
                    sbc acc0
                    sta acc0
                    pla
                    sbc acc0 + 1
                    sta acc0 + 1
                    rts
                    
+                   jmp unget
                    
divmod              +push16 acc0
                    jsr eval_b
                    +pop16 acc2
                    ldy #16
                    +mov16z ptr0
-                   +asl16 acc2
                    +rol16 ptr0
                    +cmp16 ptr0, acc0
                    bcc +
                    +sbc16 ptr0, ptr0, acc0
                    inc acc2
+                   dey
                    bne -
                    rts
                    
eval_hex            lda #16
                    sta acc1
eval_d              jsr eval_c
                    jsr lookup_token
                    ; AND
                    cmp #tok_and
                    bne +
                    +push16 acc0
                    jsr eval_d
                    pla
                    and acc0 + 1
                    sta acc0 + 1
                    pla
                    and acc0
                    sta acc0
                    rts
                    
                    ; OR
+                   cmp #tok_or
                    bne +
                    +push16 acc0
                    jsr eval_d
                    pla
                    ora acc0 + 1
                    sta acc0 + 1
                    pla
                    ora acc0
                    sta acc0
                    rts
                    
                    ; EOR
+                   cmp #tok_eor
                    bne unget
                    +push16 acc0
                    jsr eval_d
                    pla
                    eor acc0 + 1
                    sta acc0 + 1
                    pla
                    eor acc0
                    sta acc0
                    rts
                    
unget               +dec16bug cmdline
                    rts
                    
eval                php
                    pha
                    tya
                    pha
                    txa
                    pha
                    +push16 ptr0
                    +push16 acc2
                    jsr eval_hex
                    jsr skip_comma
                    +pop16 acc2
                    +pop16 ptr0
                    pla
                    tax
                    pla
                    tay
                    pla
                    plp
                    rts
                    
eval_byte           +push16 acc0
                    jsr eval
                    ldy acc0
                    lda acc0 + 1
                    beq +
                    jsr throw
                    ; "Byte out of range"
                    !text $a5, "Byte out of range", 0
+                   +pop16 acc0
                    tya
                    rts
                    
skip_comma          jsr skip_space
                    cmp #','
                    beq +
                    jmp unget
+                   rts
                    
lookup_token        lda cmd_offset
                    pha
                    +push16 cmdhelp
                    jsr lookup_command
                    tax
                    +pop16 cmdhelp
                    pla
                    sta cmd_offset
                    txa
                    rts
                    
lookup_command      jsr skip_space
                    jsr unget
                    lda #$80
                    sta acc1 + 1
                    ldx #0
lc_next_cmd         ldy #$ff
                    stx cmd_offset
lc_next_char        iny
                    lda (cmdline), y
                    and #case_mask
                    sta ptr0
                    lda cmd_table, x
                    php
                    inx
                    and #$7f
                    cmp ptr0
                    bne lc_dot
                    plp
                    bpl lc_next_char
lc_match            iny
                    tya
                    ldy #0
                    clc
                    adc cmdline
                    sta cmdline
                    bcc lc_copy
                    inc cmdline + 1
lc_copy             lda cmd_table, x
                    sta cmdjmp, y
                    inx
                    iny
                    cpy #4
                    bcc lc_copy
                    lda acc1 + 1
                    rts
                    
                    ; check for . abbreviation of command
lc_dot              plp
                    inc acc1 + 1
                    dex
                    dex
-                   inx
                    lda cmd_table, x
                    bpl -
                    inx
                    lda (cmdline), y
                    cmp #'.'
                    beq lc_match
                    inx
                    inx
                    inx
                    inx
                    lda cmd_table, x
                    bne lc_next_cmd
                    jmp getch
                    
                    ; "Syntax: "
syntax_prefix       !text "Syntax: "

check_eol           jsr skip_space
                    bne syntax_error
                    rts
                    
syntax_error        ldx #0
                    stx stack
                    lda acc1 + 1
                    sta stack + 1
                    ldy cmd_offset
                    cpy #$ff
                    bne syn_copy
                    jsr throw
                    ; "Bad expression"
                    !text $a6, "Bad expression", 0
syn_copy            lda syntax_prefix, x
                    sta stack + 2, x
                    inx
                    cpx #8
                    bcc syn_copy
-                   lda cmd_table, y
                    php
                    and #$7f
                    sta stack + 2, x
                    iny
                    inx
                    plp
                    bpl -
                    lda #' '
                    sta stack + 2, x
                    ldy #0
-                   lda (cmdhelp), y
                    php
                    and #$7f
                    sta stack + 3, x
                    iny
                    inx
                    plp
                    bpl -

stack_jmp           lda #0
                    sta stack + 3, x
                    jmp stack
                    
parse_bytes         ldx #0
parse_bytes_tail    jsr skip_comma
                    jsr skip_space
                    cmp #$22
                    bne ++
-                   jsr getch
                    cmp #$22
                    bne +
                    jsr getch
                    cmp #$22
                    bne ++
+                   cmp #13
                    beq +++
                    jsr try_poke
                    jmp -
                    
++                  jsr unget
                    jsr skip_space

                    ; $ = peek?
                    cmp #'$'
                    beq ++
                    jsr unget
                    jsr skip_space
                    cmp #13
                    bne +
                    rts
                    
+                   jsr unget
                    jsr skip_comma
                    jsr eval_byte
                    jsr try_poke
                    jmp parse_bytes_tail
                    
+++                 jmp syntax_error
                    
++                  jsr eval
                    ldy #0
-                   lda (acc0), y
                    iny
                    cmp #13
                    beq parse_bytes_tail
                    sty acc1
                    jsr try_poke
                    ldy acc1
                    jmp -
                    
try_poke            ldy #0
                    sta (ptr0), y
                    cmp (ptr0), y
                    beq +

                    jsr throw
                    !text $a7, "Read only memory", 0

+                   +inc16 ptr0
                    inx
                    rts
                    
acc0_to_acc2        +mov16 acc2, acc0
                    rts
                    
c_find              jsr parse_range
                    ldx #0
                    stx ptr0
                    inx
                    stx ptr0 + 1
                    jsr parse_bytes
                    stx cmdline
-                   ldy #0
                    ldx #0
--                  lda stack, x
                    cmp (acc2), y
                    bne +
                    iny
                    inx
                    cpx cmdline
                    bcc --
                    lda acc2 + 1
                    jsr hexbyte
                    lda acc2
                    jsr hexbyte_space
                    jsr check_escape
+                   inc acc2
                    bne +
                    inc acc2 + 1
+                   +cmp16 acc2, acc0
                    bcc -
                    jmp newline
                    
c_change            jsr eval
                    +mov16 ptr0, acc0
                    jmp parse_bytes
                    
print_or_page       jsr skip_space
                    beq ret1
                    cmp #','
                    beq print_or_page
                    and #case_mask
                    cmp #'P'
                    bne +
                    lda #14
                    jsr oswrch
                    bne print_or_page
+                   cmp #'L'
                    bne +
                    jsr enable_printer
                    jmp print_or_page
                    
+                   cmp #13
                    beq ret1
                    jmp syntax_error
                    
ret1                rts
                    
                    ; flush buffers
enable_printer      lda #$0f
                    ldx #0
                    ldy #0
                    jsr osbyte
                    lda #2
                    jsr oswrch
                    jsr skip_space
                    cmp #'*'
                    beq ret1
                    jsr unget
                    lda #' '
                    jsr oswrch
                    lda #13
                    jsr oswrch
                    lda #3
                    jsr oswrch
                    lda #$80
                    dey
                    ldx #$fc
                    jsr osbyte
                    cpx #$3f
                    bne throw_noprinter
                    lda #2
                    jmp oswrch
                    
throw_noprinter     jsr throw
                    ; "No printer"
                    !text $a8, "No printer", 0
                    
parse_range         jsr eval
                    jsr acc0_to_acc2
                    jsr skip_space
                    cmp #'.'
                    bne +
                    jsr skip_space
                    cmp #'.'
                    beq ++
                    jmp syntax_error
                    
+                   jsr unget
                    ; $ffff = end of memory
                    lda #$ff
                    sta acc0
                    sta acc0 + 1
                    rts
                    
++                  jmp eval
                    
reset_terminal      jsr prstr
                    ; disable printer, page mode off
                    !text 3, 15, 0
                    rts
                    
calc_columns        jsr osnewl
                    lda #8
                    jsr oswrch
                    lda #$86
                    jsr osbyte
                    jsr newline
                    lda #16
                    cpx #80 - 1
                    beq +
                    lsr
+                   rts
                    
ram_warning         txa
                    pha
                    tya
                    pha
                    jsr prstr
                    !text "RAM from ", 0
                    pla
                    jsr hexbyte
                    tya
                    jsr hexbyte_space
                    jsr prstr
                    !text "to ", 0
                    pla
                    jsr hexbyte
                    tya
                    jsr hexbyte_space
                    jsr prstr
                    !text "will be corrupted", 13, 0

ask_continue        jsr prstr
                    !text "continue (Y/N) ? ", 0
                    jsr osrdch
                    bcc +
                    jmp throw_escape
                    
+                   and #case_mask
                    cmp #'Y'
                    beq +
                    lda #'N'
+                   jsr oswrch
                    pha
                    jsr newline
                    pla
                    lsr
ret2                rts
                    
c_monitor           jsr skip_space
                    cmp #13
                    beq +
                    jsr unget
                    +mov16 stack, cmdline
                    lda #$83
                    jsr osbyte
                    +stxy stack + 2
                    lda #$82
                    jsr osbyte
                    +stxy stack + 4
                    ldx #0
                    stx stack + 6
                    ldy #$01
                    lda #$ff
                    jsr osfile
+                   ldx cur_rom
                    lda #$8e
                    jmp osbyte
                    
                    ; address
readline_parms      !word cmd_line
                    ; length
                    !byte cmd_line_len - 2
                    ; min char
                    !byte ' '
                    ; max char
                    !byte $ff

empty               !text 13, 0, 0, 0
                    
                    ; ROM service entry
language            cmp #1
                    bne ret2
                    +mov16i brkv, brk_handler
                    lda #0
                    ldx #$3f
                    sta base_addr
                    sta base_addr + 1
                    sta rom_sel
-                   sta breakpoints, x
                    dex
                    bpl -
                    ldx #4
-                   lda empty, x
                    sta brk_cmd, x
                    dex
                    bpl -
                    inx
                    stx $0604
                    lda #$f0
                    sta reg_s
                    lda #$5d
                    sta prompt
                    cli
                    cld
                    jmp repl
                    
brk_handler         txa
                    pha
                    ldx #0
                    lda err
                    sec
                    sbc #1
                    sta acc0
                    lda err + 1
                    sbc #0
                    sta acc0 + 1
-                   lda acc0
                    cmp breakpoints, x
                    bne +
                    lda acc0 + 1
                    cmp breakpoints + 1, x
                    bne +
                    jmp bp_handler
                    
+                   inx
                    inx
                    inx
                    inx
                    cpx #n_breakpoints * 4
                    bcc -
                    lda #$7e
                    jsr osbyte
                    jsr osnewl
                    ldy #$01
-                   lda (err), y
                    beq +
                    iny
                    cmp #' '
                    bcc -
                    cmp #$7f
                    beq -
                    jsr oswrch
                    bne -
+                   cli
                    cld
                    ldx #$ff
                    txs
                    jsr osnewl
                    
                    ; start of repl loop
repl                jsr set_private
                    ldx #0
-                   lda prompt, x
                    inx
                    jsr oswrch
                    bne -
                    sta cmdline
                    ; readline_parms
                    ldx #< readline_parms
                    ldy #> readline_parms
                    jsr osword
                    bcc repl_next
                    jmp throw_escape
                    
repl_next           ldx #$07
                    stx cmdline + 1
                    jsr skip_space
                    beq repl

                    ; :<var> =
                    cmp #':'
                    bne ++
                    jsr skip_space
                    and #case_mask
                    cmp #'A'
                    bcs +
-                   jmp throw_badvar
                    
+                   cmp #'Z' + 1
                    bcs -
                    asl
                    tax
                    ldy #$ff
                    sty cmd_offset
                    jsr skip_space
                    cmp #"="
                    beq +

throw_missingeq     jsr throw
                    !text $a9, "Missing =", 0

+                   jsr eval
                    jsr check_eol
                    lda acc0
                    sta vars + '?' * 2, x
                    lda acc0 + 1
                    sta vars + '?' * 2 + 1, x
                    jmp repl
                    
                    ; / = set prompt
++                  cmp #'/'
                    bne ++
                    ldx #0
-                   jsr getch
                    cmp #$0d
                    beq +
                    sta prompt, x
                    inx
                    bne -
+                   lda #0
                    sta prompt, x
                    jmp repl
                    
                    ; ? = show help
++                  cmp #'?'
                    bne +
                    jsr show_help
                    jmp repl
                    
                    ; $<addr> = bytestring
+                   cmp #'$'
                    bne +
                    jsr eval
                    +mov16 ptr0, acc0
                    jsr skip_space
                    cmp #$3d
                    bne throw_missingeq
                    jsr parse_bytes
                    lda #$0d
                    jsr try_poke
                    jmp repl
                    
                    ; attempt command
+                   jsr unget
                    jsr dispatch_cmd
                    bcs +
                    jmp repl
                    
                    ; fallback to oscli
+                   ldx #< cmd_line
                    ldy #> cmd_line
                    jsr oscli
                    jmp repl
                    
bp_handler          pla
                    sta reg_x
                    lda $fc
                    sta reg_a
                    sty reg_y
                    pla
                    sta reg_p
                    jsr prstr
                    !text "Break: PC = ", 0
                    lda acc0 + 1
                    jsr hexbyte
                    lda acc0
                    jsr hexbyte
                    jsr newline
                    lda #$a0
                    sta cmdline
                    jmp repl_next
                    
do_calc             jsr eval
                    jsr check_eol
                    ldy #2
                    ldx #18
                    jsr radix_print
                    ldy #8
                    ldx #8
                    jsr radix_print
                    ldy #10
                    ldx #7
                    jsr radix_print
                    ldy #16
                    ldx #6
                    jsr radix_print
                    lda $0402
                    cmp #$02
                    bcc +
                    cmp #$24
                    bcs +
                    ldx cur_rom
                    ldy rom_private, x
                    bpl +
                    pha
                    jsr prstr
                    !text 13, "Base ", 0
                    pla
                    pha
                    tay
                    +push16 acc0
                    ldx #0
                    stx acc0 + 1
                    sty acc0
                    ldy #10
                    jsr radix_print
                    +pop16 acc0
                    jsr prstr
                    !text ": ", 0
                    pla
                    tay
                    ldx #0
                    beq radix_print
+                   rts
                    
radix_print         +push16 acc0
                    tya
                    jsr radix_out
                    +pop16 acc0
                    rts
                    
c_calc              jsr do_calc
                    jmp newline
                    
c_move              lda #0
                    sta stack
                    jsr skip_space
                    cmp #'>'
                    bne +
                    sta stack
                    beq ++
+                   jsr unget
++                  jsr eval
                    jsr acc0_to_acc2
                    jsr eval
                    lda #$83
                    jsr osbyte
                    txa
                    cmp acc0
                    tya
                    sbc acc0 + 1
                    bcc +
                    lda stack
                    bne +
                    txa
                    pha
                    tya
                    pha
                    jsr prstr
                    !text "Destination <= ", 0
                    pla
                    jsr hexbyte
                    pla
                    jsr hexbyte
                    jsr newline
                    jsr ask_continue
                    bcs +
                    rts
                    
+                   +mov16 ptr0, acc0
                    jsr eval
                    lda stack
                    bne +
                    jsr check_eol
+                   ldy #0
                    +cmp16 ptr0, acc2
                    bcc move_next
                    clc
                    +adc16 acc2, acc2, acc0
                    clc
                    +adc16 ptr0, ptr0, acc0
                    +inc16 acc0
-                   lda (acc2), y
                    sta (ptr0), y
                    +dec16 acc2
                    +dec16 ptr0
                    jsr countdown
                    bne -
                    rts
                    
move_next           lda (acc2), y
                    jsr try_poke
                    +inc16 acc2
                    jsr countdown
                    bne move_next
                    lda stack
                    beq +
                    jsr eval
                    jsr check_eol
                    jmp (acc0)
                    
+                   rts
                    
countdown           +dec16 acc0
                    +cmz16 acc0
                    rts
                    
set_private         lda #$ff
                    bne +

clr_private         lda #0
+                   ldx cur_rom
                    sta rom_private, x
                    rts
                    
get_private         ldx cur_rom
                    lda rom_private, x
-                   rts
                    
check_cmd_mode      jsr get_private
                    bmi -
                    jsr throw
                    ; "Command mode only"
                    !text $aa, "Command mode only", 0

addr_modes          
addr_zp             !byte a_zp    - addr_modes
addr_zpi            !byte a_zpi   - addr_modes
addr_abs            !byte a_abs   - addr_modes
addr_absix          !byte a_absix - addr_modes
addr_absy           !byte a_absy  - addr_modes
addr_absi           !byte a_absi  - addr_modes
addr_zpiy           !byte a_zpiy  - addr_modes
addr_zpix           !byte a_zpix  - addr_modes
addr_a              !byte a_a     - addr_modes
addr_impl           !byte a_impl  - addr_modes
addr_imm            !byte a_imm   - addr_modes
addr_rel            !byte a_rel   - addr_modes

a_zp                !text "H1", 0
a_zpi               !text "H1,I", 0
a_abs               !text "2", 0
a_absix             !text "2,I", 0
a_absy              !text "2,Y", 0
a_absi              !text "(2)", 0
a_zpiy              !text "(H1),Y", 0
a_zpix              !text "(H1,X)", 0
a_a                 !text "A", 0
a_impl              !text " ", 0
a_imm               !text "#H1", 0
a_rel               !text "H+", 0
                    !text 13, 12

                    ; first two bytes are 5 bits-per-char encodings of mnemonic
                    ; second two bytes are mask and bit pattern


op_decode           +mnem 'B', 'C', 'C', $90, $ff
                    +mnem 'B', 'C', 'S', $b0, $ff
                    +mnem 'B', 'E', 'Q', $f0, $ff
                    +mnem 'B', 'M', 'I', $30, $ff
                    +mnem 'B', 'N', 'E', $d0, $ff
                    +mnem 'B', 'P', 'L', $10, $ff
                    +mnem 'B', 'R', 'K', $00, $ff
                    +mnem 'B', 'V', 'C', $50, $ff
                    +mnem 'B', 'V', 'S', $70, $ff
                    +mnem 'C', 'L', 'C', $18, $ff
                    +mnem 'C', 'L', 'D', $d8, $ff
                    +mnem 'C', 'L', 'I', $58, $ff
                    +mnem 'C', 'L', 'V', $b8, $ff
                    +mnem 'D', 'E', 'X', $ca, $ff
                    +mnem 'D', 'E', 'Y', $88, $ff
                    +mnem 'I', 'N', 'X', $e8, $ff
                    +mnem 'I', 'N', 'Y', $c8, $ff
                    +mnem 'J', 'S', 'R', $20, $ff
                    +mnem 'N', 'O', 'P', $ea, $ff
                    +mnem 'P', 'H', 'A', $48, $ff
                    +mnem 'P', 'H', 'P', $08, $ff
                    +mnem 'P', 'L', 'A', $68, $ff
                    +mnem 'P', 'L', 'P', $28, $ff
                    +mnem 'R', 'T', 'I', $40, $ff
                    +mnem 'R', 'T', 'S', $60, $ff
                    +mnem 'S', 'E', 'C', $38, $ff
                    +mnem 'S', 'E', 'D', $f8, $ff
                    +mnem 'S', 'E', 'I', $78, $ff
                    +mnem 'T', 'A', 'X', $aa, $ff
                    +mnem 'T', 'A', 'Y', $a8, $ff
                    +mnem 'T', 'S', 'X', $ba, $ff
                    +mnem 'T', 'X', 'A', $8a, $ff
                    +mnem 'T', 'X', 'S', $9a, $ff
                    +mnem 'T', 'Y', 'A', $98, $ff
                    +mnem 'B', 'I', 'T', $24, $f7
                    +mnem 'J', 'M', 'P', $4c, $df
                    +mnem 'C', 'P', 'X', $e0, $f3
                    +mnem 'C', 'P', 'Y', $c0, $f3
                    +mnem 'S', 'T', 'X', $86, $e7
                    +mnem 'S', 'T', 'Y', $84, $e7
                    +mnem 'D', 'E', 'C', $c6, $e7
                    +mnem 'I', 'N', 'C', $e6, $e7
                    +mnem 'A', 'S', 'L', $02, $e3
                    +mnem 'L', 'S', 'R', $42, $e3
                    +mnem 'R', 'O', 'L', $22, $e3
                    +mnem 'R', 'O', 'R', $62, $e3
                    +mnem 'L', 'D', 'X', $a2, $e3
                    +mnem 'L', 'D', 'Y', $a0, $e3
                    +mnem 'S', 'T', 'A', $81, $e3
                    +mnem 'A', 'D', 'C', $61, $e3
                    +mnem 'A', 'N', 'D', $21, $e3
                    +mnem 'C', 'M', 'P', $c1, $e3
                    +mnem 'E', 'O', 'R', $41, $e3
                    +mnem 'L', 'D', 'A', $a1, $e3
                    +mnem 'O', 'R', 'A', $01, $e3
                    +mnem 'S', 'B', 'C', $e1, $e3
                    !byte 0, 0, 0, 0
op_decode_end

                    !byte 0, 0

                    ; Maps opcode, mask to offset index in
                    ; addr_modes. Would be more efficient
                    ; to map directly to offset
addr_decode         !byte $20, $ff, addr_abs   - addr_modes
                    !byte $10, $1f, addr_rel   - addr_modes 
                    !byte $09, $1f, addr_imm   - addr_modes
                    !byte $0a, $9f, addr_a     - addr_modes
                    !byte $08, $0d, addr_impl  - addr_modes
                    !byte $00, $9f, addr_impl  - addr_modes
                    !byte $4c, $ff, addr_abs   - addr_modes
                    !byte $80, $9d, addr_imm   - addr_modes
                    !byte $84, $9d, addr_zp    - addr_modes
                    !byte $8c, $9d, addr_abs   - addr_modes
                    !byte $94, $9d, addr_zpi   - addr_modes
                    !byte $9c, $9d, addr_absix - addr_modes
                    !byte $6c, $ff, addr_absi  - addr_modes
                    !byte $00, $1c, addr_zpix  - addr_modes
                    !byte $04, $1c, addr_zp    - addr_modes
                    !byte $0c, $1c, addr_abs   - addr_modes
                    !byte $10, $1c, addr_zpiy  - addr_modes
                    !byte $14, $1c, addr_zpi   - addr_modes
                    !byte $18, $1c, addr_absy  - addr_modes
                    !byte $1c, $1c, addr_absix - addr_modes
addr_decode_end

                    ; Illegal opcodes
bad_op              !byte $04, $0c, $12, $14, $1a, $1c, $22, $32
                    !byte $34, $3a, $3c, $42, $44, $52, $54, $5a
                    !byte $5c, $62, $64, $72, $74, $7a, $7c, $80
                    !byte $82, $89, $92, $9c, $9e, $b2, $c2, $d2
                    !byte $d4, $da, $dc, $e2, $f2, $f4, $fa, $fc
bad_op_end

                    jsr stack_jmp
                    lda #$0d
peek                ldx #0
                    stx acc3
read_rom            php
                    sei
                    tya
                    pha
                    lda acc2
                    sta $f6
                    lda acc2 + 1
                    sta $f7
                    jsr get_private
                    bmi +
                    txa
                    bpl ++
+                   lda rom_sel
++                  tay
                    jsr $ffb9
                    +inc16 acc2
                    pha
                    inc acc3
                    lda acc3
                    and #$07
                    tax
                    pla
                    sta stack + 10, x
                    tax
                    pla
                    tay
                    txa
                    plp
                    rts
                    
dump_line           txa
                    pha
                    lda acc2 + 1
                    pha
                    jsr hexbyte
                    lda acc2
                    pha
                    jsr hexbyte_space
-                   txa
                    pha
                    jsr peek
                    jsr hexbyte_space
                    pla
                    tax
                    dex
                    bne -
                    pla
                    sta acc2
                    pla
                    sta acc2 + 1
                    pla
                    tax
-                   txa
                    pha
                    jsr peek
                    jsr safe_ascii
                    pla
                    tax
                    dex
                    bne -
                    rts
                    
-                   lda #'.'
safe_ascii          cmp #' '
                    bcc -
                    cmp #$7f
                    bcs -
                    jmp oswrch
                    
c_mem               jsr parse_range
                    jsr calc_columns
                    pha
                    jsr print_or_page
-                   pla
                    pha
                    tax
                    jsr dump_line
                    jsr newline
                    +cmp16 acc2, acc0
                    bcc -
                    pla
                    jmp reset_terminal
                    
decode_admode       ldy #0
                    sty acc3
                    jsr read_rom
-                   pha
                    and addr_decode + 1, y
                    cmp addr_decode, y
                    beq +
                    pla
                    iny
                    iny
                    iny
                    cpy #addr_decode_end - addr_decode + 2
                    bcc -
                    pha
+                   pla
                    lda addr_decode + 2, y
                    cmp #$0c
                    bcs +
                    ldx acc3 + 1
                    beq +
                    tay
                    lda #' '
                    jsr oswrch
                    lda addr_modes, y 
                    tay
-                   lda addr_modes, y 
                    beq +
                    iny

                    cmp #'1'
                    bne ++
                    jsr read_rom
                    jsr hexbyte
                    jmp -
                    
++                  cmp #'2'
                    bne ++
                    jsr pr_sym16
                    jmp -
                    
++                  cmp #'+'
                    bne ++
                    jsr read_rom
                    tax
                    +push16 acc2
                    txa
                    php
                    ldx #0
                    plp
                    bpl +++
                    dex
+++                 clc
                    adc acc2
                    sta acc2
                    txa
                    adc acc2 + 1
                    sta acc2 + 1
                    jsr pr_addr
                    +pop16 acc2
                    jmp -
                    
++                  cmp #'I'
                    bne ++
                    lda acc3 + 1

++                  cmp #'H'
                    bne ++
                    lda hex_pfx
++                  jsr oswrch
                    jmp -
                    
+                   rts
                    
pr_addr             clc
                    lda acc2
                    adc ptr0
                    pha
                    lda acc2 + 1
                    adc ptr0 + 1
                    jsr hexbyte
                    pla
                    jmp hexbyte
                    
decode_instr        +push16 acc2
                    lda #'X'
                    sta acc3 + 1
                    jsr read_rom

                    ; illegal op?
                    ldx #0
-                   cmp bad_op, x
                    beq +
                    inx
                    cpx #bad_op_end - bad_op
                    bcc -
                    tax
                    and #$03
                    cmp #$03
                    bne ++
+                   ldx #$0b ; indicate bad op
                    lda #0
                    sta acc3 + 1

                    ; lookup op
++                  txa
                    ldx #0
-                   pha
                    and op_decode + 3, x
                    cmp op_decode + 2, x
                    beq +
                    pla
                    inx
                    inx
                    inx
                    inx
                    cpx #op_decode_end - op_decode
                    bcc -
                    pha
+                   pla     ; found match

                    ; stash packed mnemonic
                    lda op_decode, x
                    sta stack
                    lda op_decode + 1, x
                    sta stack + 1

                    ; decode 2 bytes -> 3 chars
                    ldy #3
-                   ldx #5
                    lda #0
--                  +asl16 stack
                    rol
                    dex
                    bne --
                    clc
                    adc #'?'
                    jsr oswrch
                    cmp #'X'
                    bne +
                    inc acc3 + 1
+                   dey
                    bne -
                    +pop16 acc2
                    rts
                    
dis_op              jsr pr_addr
                    lda #' '
                    jsr oswrch
                    jsr decode_instr
                    jsr decode_admode
                    lda #$86
                    jsr osbyte
                    lda #' '
-                   jsr oswrch
                    inx
                    cpx #19
                    bcc -
                    ldy #0
-                   lda stack + 11, y
                    jsr hexbyte_space
                    iny
                    cpy acc3
                    bcc -
                    lda #$86
                    jsr osbyte
                    lda #' '
-                   jsr oswrch
                    inx
                    cpx #$1d
                    bcc -
                    ldy #0
-                   lda stack + 11, y
                    jsr safe_ascii
                    iny
                    cpy acc3
                    bcc -
                    jmp newline
                    
c_base              jsr check_cmd_mode
                    jsr eval
                    jsr check_eol
                    +mov16 base_addr, acc0
                    rts
                    
copyright_marker    !text 0, "(C)"
                    
c_select            jsr check_cmd_mode
                    jsr eval_byte
                    pha
                    jsr check_eol
                    pla
                    cmp #$10
                    bcc +
-                   jsr throw
                    !text $ab, "Bad ROM", 0
+                   sta rom_sel
                    +mov16i acc2, copyright_offset
                    jsr read_rom
                    sta acc2
                    ldx #$04
--                  txa
                    pha
                    jsr read_rom
                    tay
                    pla
                    tax
                    cpy copyright_marker   ; seems dodgy
                    bne -
                    inx
                    cpx #$04
                    bcc --
                    lda #$09
                    sta acc2
                    jsr prstr
                    ; "Rom: "
                    !text "Rom: ", 0
-                   jsr read_rom
                    jsr oswrch
                    bne -
                    jmp newline
                    
c_dis               jsr parse_range
                    jsr get_private
                    bmi +
-                   lda acc2
                    ldx acc2 + 1
                    jmp ++
                    
+                   +cmz16 base_addr
                    beq -
                    lda base_addr
                    ldx base_addr + 1
++                  sta ptr0
                    stx ptr0 + 1
                    sec
                    +sbc16 ptr0, ptr0, acc2
                    jsr hex_prefix
                    jsr print_or_page
-                   jsr dis_op
                    +cmp16 acc2, acc0
                    bcc -
                    jmp reset_terminal
                    
hex_prefix          jsr skip_space
                    cmp #'H'
                    bne +
                    jsr skip_space
                    bne ++
+                   jsr unget
                    lda #'&'
++                  sta hex_pfx
                    rts
                    
service             php
                    pha
                    txa
                    pha
                    tya
                    pha
                    +push16 cmdline
                    clc
                    tya
                    +adca16 cmdline
                    tsx
                    lda stack + 5, x
                    
                    ; star command not recognised?
                    cmp #4
                    beq star_command

                    ; *help?
                    cmp #9
                    beq help

service_done        +pop16 cmdline
                    pla
                    tay

service_exit        pla
                    tax
                    pla
                    plp
                    rts
                    
help                jsr skip_space
                    php
                    jsr unget
                    plp
                    beq +
                    jsr lookup_command
                    cmp #$8f
                    bne ++
                    jsr show_help
                    jmp +++
                    
+                   jsr pr_banner
++                  jmp service_done
                    
star_command        jsr clr_private
                    jsr dispatch_cmd
                    bcs ++
+++                 tsx
                    lda #0
                    sta stack + 5, x
                    pla
                    pla
                    pla
                    ldy #0
                    beq service_exit
++                  jmp service_done
                    
regnames            !text "AXYS"
regnames_end

flagnames           !text "nv.bdizc"
flagnames_end
                    
show_regs           jsr check_eol
                    ldx #0
-                   lda regnames, x
                    pha
                    jsr oswrch
                    jsr prstr
                    !text " = ", 0
                    pla
                    asl
                    tay
                    lda vars + '?' * 2, y   ; odd calculation - would expect to sub from base
                    jsr hexbyte_space
                    inx
                    cpx #regnames_end - regnames
                    bcc -
                    jsr prstr
                    !text 13, "P = ", 0
                    
show_flags          ldy #0
                    lda reg_p
-                   ldx #'.'
                    asl
                    bcc +
                    ldx flagnames, y
+                   pha
                    txa
                    jsr oswrch
                    pla
                    iny
                    cpy #flagnames_end - flagnames
                    bcc -
                    rts
                    
c_regs              jsr show_regs
                    jmp newline
                    
c_go                jsr check_cmd_mode
                    jsr eval
                    ldx #0
-                   jsr skip_space
                    beq +
                    jsr unget
                    lda regnames, x
                    asl
                    sta stack
                    jsr eval_byte
                    ldy stack
                    sta vars + '?' * 2, y
                    inx
                    cpx #regnames_end - regnames
                    bcc -
                    jmp syntax_error
                    
+                   php
                    jsr load_regs
                    jsr go_acc
                    jsr save_regs
                    plp

                    jmp newline
                    
go_acc              jmp (acc0)
                    
load_regs           lda reg_p
                    pha
                    lda reg_a
                    ldx reg_x
                    ldy reg_y
                    plp
                    rts
                    
save_regs           php
                    sta reg_a
                    stx reg_x
                    sty reg_y
                    pla
                    sta reg_p
                    rts
                    
c_where             jsr check_cmd_mode
                    jsr check_eol
                    jsr prstr
                    !text "Breakpoints:", 13, 0
                    ldx #0
-                   lda breakpoints, x
                    ora breakpoints + 1, x
                    beq +
                    lda breakpoints + 1, x
                    jsr hexbyte
                    lda breakpoints, x
                    jsr hexbyte_space
+                   inx
                    inx
                    inx
                    inx
                    cpx #n_breakpoints * 4
                    bcc -
                    jmp newline
                    
c_set               jsr check_cmd_mode
                    jsr eval
                    jsr check_eol
                    ldx #0
                    +mov16 ptr0, acc0
-                   lda breakpoints, x
                    ora breakpoints + 1, x
                    beq +
                    inx
                    inx
                    inx
                    inx
                    cpx #n_breakpoints * 4
                    bcc -
                    jsr throw
                    !text $ac, "No room", 0
+                   txa
                    pha
                    lda (acc0), y
                    sta breakpoints + 2, x
                    tya
                    jsr try_poke
                    pla
                    tax
                    lda acc0
                    sta breakpoints, x
                    lda acc0 + 1
                    sta breakpoints + 1, x
                    rts
                    
c_clr               jsr check_cmd_mode
                    jsr skip_space
                    beq ++
                    jsr unget
                    jsr eval
                    jsr check_eol
                    ldx #0
-                   lda acc0
                    cmp breakpoints, x
                    bne +
                    lda acc0 + 1
                    cmp breakpoints + 1, x
                    bne +
                    lda breakpoints + 2, x
                    sta (acc0), y
                    tya
                    sta breakpoints, x
                    sta breakpoints + 1, x
                    rts
                    
+                   inx
                    inx
                    inx
                    inx
                    cpx #n_breakpoints * 4
                    bcc -
                    jsr throw
                    !text $ad, "Breakpoint not found", 0
++                  ldx #0
                    ldy #0
-                   lda breakpoints, x
                    ora breakpoints + 1, x
                    beq +
                    lda breakpoints, x
                    sta acc0
                    lda breakpoints + 1, x
                    sta acc0 + 1
                    lda breakpoints + 2, x
                    sta (acc0), y
                    tya
                    sta breakpoints, x
                    sta breakpoints + 1, x
+                   inx
                    inx
                    inx
                    inx
                    cpx #n_breakpoints * 4
                    bcc -
                    rts
                    
c_onbrk             jsr check_cmd_mode
                    ldx #0
-                   jsr getch
                    sta brk_cmd, x
                    inx
                    cmp #13
                    bne -
                    rts
                    
get_put_parms       sta stack
                    stx stack + 9
                    sty stack + 6
                    +mov16 stack + 7, acc0

                    ; page
                    lda #$83
                    jsr osbyte
                    +stxy stack + 1

                    ; machine address
                    lda #$82
                    jsr osbyte
                    +stxy stack + 3

                    lda #$03
                    sta stack + 5
                    lda #$7f
                    ldx #< stack
                    ldy #> stack
                    rts
                    
get_drive           lda #$01
                    sta stack
                    ; machine high order address
                    lda #$82
                    jsr osbyte
                    +stxy stack + 3
                    lda #< stack + 8
                    sta stack + 1
                    ldy #> stack + 8
                    sty stack + 2
                    lda #$06
                    ldx #0
                    jsr osgbpb
                    lda stack + 9
                    and #$03
                    rts
                    
c_verify            jsr get_drive
                    pha
                    jsr skip_space
                    bne +
                    pla
                    pha
                    jmp ++
                    
+                   jsr unget
                    jsr eval_byte
                    pha
                    jsr check_eol
                    pla
                    cmp #$04
                    bcc ++

throw_baddrive      jsr throw
                    ; "Bad drive"
                    !text $ae, "Bad drive", 0

++                  jsr star_drive
                    sta ptr0
                    +mov16z acc0
                    jsr disk_size
-                   lda acc0
                    jsr hexbyte
                    lda ptr0
                    ldx #$2a
                    ldy #$5f
                    jsr get_put_parms
                    jsr osword
                    lda #' '
                    ldx stack + 10
                    beq +
                    lda #'?'
+                   jsr oswrch
                    lda #' '
                    jsr oswrch
                    inc acc0
                    sec
                    lda acc2
                    sbc #10
                    sta acc2
                    bcs +
                    dec acc2 + 1
+                   ora acc2 + 1
                    bne -
                    pla
                    jmp star_drive
                    
disk_size           lda cmdhelp + 1
                    pha
                    lda acc3
                    pha
                    ldx #< cmdhelp + 1
                    ldy #> cmdhelp + 1
                    lda #$7e
                    jsr osword
                    pla
                    sta acc3
                    pla
                    sta cmdhelp + 1
                    rts
                    
drive_cmd           !text "DRIVE "
drive_cmd_end

star_drive          pha
                    ldx #0
-                   lda drive_cmd, x
                    sta stack + 10, x
                    inx
                    cpx #drive_cmd_end - drive_cmd
                    bcc -
                    pla
                    ora #'0'
                    sta stack + 16
                    lda #13
                    sta stack + 17
                    ldx #$0a
                    ldy #$01
                    jmp oscli
                    
show_fkeys          ldy #0
-                   jsr show_fkey
                    iny
                    cpy #16
                    bcc -
                    rts
                    
c_flist             jsr skip_space
                    beq show_fkeys
                    jsr unget
                    jsr eval_byte
                    cmp #16
                    bcc +
                    jsr throw
                    !text $fb, "Bad key", 0
+                   tay

show_fkey           sty acc0
                    jsr prstr
                    !text "*KEY", 0
                    jsr check_escape
                    ldx #0
                    stx acc0 + 1
                    ldy #10
                    jsr radix_print
                    lda acc0
                    ora #$80
                    tay
                    ldx #0
                    lda #$8a
                    jsr osbyte
                    jsr prstr
                    !text -2, 0
-                   lda #4
                    ldx #2
                    jsr osbyte
                    lda #$81
                    ldy #0
                    ldx #0
                    jsr osbyte
                    cpy #0
                    bne +
                    txa
                    jsr esc_char
                    jmp -
                    
+                   lda #4
                    ldx #0
                    jsr osbyte
                    ldy acc0
                    jmp newline
                    
esc_char            ldx #'|'
                    cmp #$80
                    bcc +
                    pha
                    txa
                    jsr oswrch
                    lda #'!'
                    jsr oswrch
                    pla
                    and #$7f
+                   cmp #' '
                    bcs +
                    pha
                    txa
                    jsr oswrch
                    pla
                    ora #'@'
+                   cmp #'|'
                    bne +
                    jsr oswrch
+                   cmp #$7f
                    bne +
                    txa
                    jsr oswrch
                    lda #'?'
+                   jmp oswrch
                    
times3              sta stack
                    asl
                    clc
                    adc stack
                    rts
                    
div3                sta stack
                    ldx #8
                    lda #0
-                   asl stack
                    rol
                    cmp #3
                    bcc +
                    sbc #3
                    inc stack
+                   dex
                    bne -
                    sta stack + 1
                    rts
                    
show_line           +push16 acc2
                    jsr cursor_off
                    lda #13
                    jsr oswrch
                    ldx acc0 + 1
                    jsr dump_line
                    lda #$86
                    jsr osbyte
                    lda #31
                    jsr oswrch
                    lda acc0
                    jsr oswrch
                    tya
                    jsr oswrch
                    +pop16 acc2
                    jmp cursor_on
                    
c_edit              jsr eval
                    jsr acc0_to_acc2
                    jsr check_eol
                    jsr prstr
                    ; restore default windows, clear screen
                    !text 26, 12, 0
                    +push16 acc2
                    jsr calc_columns
                    sta acc0 + 1
                    ldy #0
                    sty ptr0 + 1
                    ldx #0
                    ldy #0
                    cmp #8
                    beq edit_copy_layout
                    ldy #layout_80 - layout_40
edit_copy_layout    lda layout_40, y
                    sta cmdjmp, x
                    iny
                    inx
                    cpx #layout_80 - layout_40
                    bcc edit_copy_layout
-                   ldx acc0 + 1
                    jsr dump_line
                    jsr newline

                    ; read cursor position
                    lda #$86
                    jsr osbyte
                    cpy ptr0 + 1
                    beq +
                    sty ptr0 + 1
                    bne -
+                   lda #5
                    sta acc0
                    +pop16 acc2
                    jsr prstr

                    ; move cursor home
                    !text 30, 0

                    ; setup keyboard
                    lda #$04
                    ldx #$02
                    jsr osbyte

                    ; function key base code
                    lda #$e1
                    ldx #$7c
                    ldy #0
                    jsr osbyte

                    ; shift function key base code
                    lda #$e2
                    ldx #$94
                    ldy #0
                    jsr osbyte

edit_getch          jsr show_line
                    ; flush input buffers
                    lda #$0f
                    ldx #$01
                    jsr osbyte
                    jsr osrdch
                    bcc edit_dispatch
                    ; ack escape and exit
                    lda #$7e
                    jsr osbyte
                    lda #$04
                    ldx #0
                    jsr osbyte
                    lda #$e1
                    ldx #$01
                    jsr osbyte
                    lda #$e2
                    ldx #$01
                    jsr osbyte
                    jmp newline
                    
                    ; left
edit_dispatch       cmp #key_left
                    bne is_right
                    lda acc0
                    cmp #5
                    beq +
                    cmp cmdjmp + 1
                    beq ++
                    dec acc0
                    bne edit_getch
+                   lda cmdjmp
                    bne +
++                  lda cmdhelp
+                   sta acc0
                    ; fake up
                    lda #key_up
                    bne is_up

                    ; right
is_right            cmp #key_right
                    bne is_down
                    lda acc0
                    cmp cmdjmp
                    beq +
                    cmp cmdhelp
                    beq ++
                    inc acc0
                    bne edit_getch
+                   lda #5
                    bne +
++                  lda cmdjmp + 1
+                   sta acc0
                    lda #key_down

                    ; down
is_down             cmp #key_down
                    bne is_up
                    jsr show_line
                    lda #10
                    jsr oswrch
                    lda acc2
                    clc
                    adc acc0 + 1
                    sta acc2
                    bcc edit_next
                    inc acc2 + 1
                    jmp edit_getch
                    
                    ; up
is_up               cmp #key_up
                    bne is_sh_right
                    jsr show_line
                    lda #11
                    jsr oswrch
                    lda acc2
                    sec
                    sbc acc0 + 1
                    sta acc2
                    bcs edit_next
                    dec acc2 + 1
                    jmp edit_getch  ; oops - duplication
                    
edit_next           jmp edit_getch
                    
                    ; shift right = skip to ascii column
is_sh_right         cmp #key_sh_right
                    bne is_sh_left
                    lda cmdjmp
                    cmp acc0
                    bcc edit_next
                    lda acc0
                    sec
                    sbc #5
                    jsr div3
                    lda stack
                    clc
                    adc cmdjmp + 1
                    sta acc0
                    jmp edit_getch
                    
                    ; shift left = skip to hex column
is_sh_left          cmp #key_sh_left
                    bne is_ret
                    lda acc0
                    cmp cmdjmp + 1
                    bcc edit_next
                    lda acc0
                    sec
                    sbc cmdjmp + 1
                    jsr times3
                    clc
                    adc #$05
                    sta acc0
                    jmp edit_getch
                    
                    ; return
is_ret              cmp #13
                    bne edit_input
                    ldx #$05
                    lda acc0
                    cmp cmdjmp + 1
                    bcc +
                    ldx cmdjmp + 1
+                   stx acc0

                    ; fake line down. Could just jump to the code after the key test
                    lda #key_down
                    jmp is_down
                    
                    ; text input
edit_input          tax
                    lda acc0
                    cmp cmdjmp + 1
                    bcc edit_hex
                    sbc cmdjmp + 1
                    tay
                    txa
                    sta (acc2), y
                    cmp (acc2), y
                    bne edit_bell

                    ; fake right. Could just jump in after the test
                    lda #key_right
                    jmp is_right
                    
edit_hex            stx acc3
-                   sbc #4
                    jsr div3
                    cmp #2
                    bne +
                    ; move forward and try again
                    inc acc0
                    lda acc0
                    clc
                    bcc -

edit_bell           lda #$07
                    jsr oswrch
                    jmp edit_getch
                    
+                   lda acc3
                    sbc #$2f
                    bcc edit_bell
                    cmp #$0a
                    bcc +
                    cmp #$11
                    bcc edit_bell
                    sbc #$07
+                   cmp #$10
                    bcs edit_bell
                    ldx #$f0
                    ldy stack + 1
                    bne +
                    ldx #$0f
                    asl
                    asl
                    asl
                    asl
+                   stx stack + 1
                    ldy stack
                    sta stack
                    lda (acc2), y
                    and stack + 1
                    ora stack
                    sta (acc2), y
                    cmp (acc2), y
                    bne edit_bell
                    ; fake right
                    lda #key_right
                    jmp is_right
                    
                    jmp edit_getch

; Full screen editor columns
layout_40           !byte 27, 29, 36
layout_80           !byte 51, 53, 68
                    
cursor_off          +push16 ptr0
                    jsr prstr
                    ; cursor off
                    !text 23, 1, 0
                    jmp +
                    
cursor_on           +push16 ptr0
                    jsr prstr
                    ; cursor on
                    !text 23, 1, 1, 0
+                   tya
                    ldx #10
-                   jsr oswrch
                    dex
                    bne -
                    +pop16 ptr0
                    rts

; Instruction lengths packed into two bit fields

inst_len_table      +ilen 1, 2, 2, 1, 1, 2, 2, 1, 1, 2, 1, 1, 1, 3, 3, 1
                    +ilen 2, 2, 1, 1, 1, 2, 2, 1, 1, 3, 1, 1, 1, 3, 3, 1
                    +ilen 3, 2, 1, 1, 2, 2, 2, 1, 1, 2, 1, 1, 3, 3, 3, 1
                    +ilen 2, 2, 1, 1, 1, 2, 2, 1, 1, 3, 1, 1, 1, 3, 3, 1
                    +ilen 1, 2, 1, 1, 1, 2, 2, 1, 1, 2, 1, 1, 3, 3, 3, 1
                    +ilen 2, 2, 1, 1, 1, 2, 2, 1, 1, 3, 1, 1, 1, 3, 3, 1
                    +ilen 1, 2, 1, 1, 1, 2, 2, 1, 1, 2, 1, 1, 3, 3, 3, 1
                    +ilen 2, 2, 1, 1, 1, 2, 2, 1, 1, 3, 1, 1, 1, 3, 3, 1
                    +ilen 1, 2, 1, 1, 2, 2, 2, 1, 1, 1, 1, 1, 3, 3, 3, 1
                    +ilen 2, 2, 1, 1, 2, 2, 2, 1, 1, 3, 1, 1, 1, 3, 1, 1
                    +ilen 2, 2, 2, 1, 2, 2, 2, 1, 1, 2, 1, 1, 3, 3, 3, 1
                    +ilen 2, 2, 1, 1, 2, 2, 2, 1, 1, 3, 1, 1, 3, 3, 3, 1
                    +ilen 2, 2, 1, 1, 2, 2, 2, 1, 1, 2, 1, 1, 3, 3, 3, 1
                    +ilen 2, 2, 1, 1, 1, 2, 2, 1, 1, 3, 1, 1, 1, 3, 3, 1
                    +ilen 2, 2, 1, 1, 2, 2, 2, 1, 1, 2, 1, 1, 3, 3, 3, 1
                    +ilen 2, 2, 1, 1, 1, 2, 2, 1, 1, 3, 1, 1, 1, 3, 3, 1

; Compute the length in bytes of the opcode in A

inst_len            pha
                    lsr
                    lsr
                    tax
                    pla
                    and #$03
                    tay
                    lda inst_len_table, x
-                   iny
                    cpy #$04
                    beq +
                    lsr
                    lsr
                    jmp -
                    
+                   and #$03
                    rts
                    
                    ; bootstrap for stepper
step_bootstrap      nop
                    nop
                    jmp stepped
                    jmp branched
step_bootstrap_end
                    
c_step              jsr check_cmd_mode
                    jsr eval
                    jsr acc0_to_acc2
                    jsr hex_prefix
                    jsr print_or_page
                    ldx reg_s
                    cpx #$80      ; or just BMI
                    bcs +
                    jsr throw
                    !text $af, "Stack overflow", 0

+                   txs
                    jsr prstr
                    !text "PC", -3, "A", -2, "X", -2, "Y", -2, "P", -8, "S", -2, "Opcode", 13, 0

                    sty ptr0
                    sty ptr0 + 1
step_next           +inc16 reg_pc
                    lda acc2 + 1
                    jsr hexbyte
                    lda acc2
                    jsr hexbyte_space
                    tsx
                    stx reg_s
                    lda reg_a
                    jsr hexbyte_space
                    lda reg_x
                    jsr hexbyte_space
                    lda reg_y
                    jsr hexbyte_space
                    lda reg_p
                    jsr show_flags
                    lda #' '
                    jsr oswrch
                    lda reg_s
                    jsr hexbyte_space
                    ldx #step_bootstrap_end - step_bootstrap - 1
-                   lda step_bootstrap, x
                    sta stack + 12, x
                    dex
                    bpl -
                    +mov16 acc0, acc2
                    inx
                    stx acc3
                    jsr decode_instr
                    ldx #0
                    stx acc3
                    jsr decode_admode
                    jsr osrdch
                    jsr newline

                    ; JMP, Bxx, RTS etc are emulated
                    lda stack + 11
                    beq do_brk
                    ; JSR
                    cmp #$20
                    beq do_jsr
                    ; JMP
                    cmp #$4c
                    beq do_jmp
                    ; JMP ()
                    cmp #$6c
                    beq do_jmpi
                    ; RTS
                    cmp #$60
                    beq do_rts
                    ; RTI
                    cmp #$40
                    beq do_rti
                    ; branch?
                    and #$1f
                    cmp #$10
                    beq do_branch

step_execute        php
                    pla
                    sta acc1
                    lda #0
                    sta acc3
                    jsr load_regs
                    jmp stack + 11
                    
do_brk              jsr throw
                    !text $b0, "Halted", 0
                    
do_jsr              jsr ex_or_step
                    bne step_execute
                    clc
                    lda acc0
                    adc #2
                    tax
                    lda acc0 + 1
                    adc #0
                    pha
                    txa
                    pha
                    
do_jmp              jsr next_pc
                    jsr indirect
                    jmp step_next
                    
do_jmpi             jsr next_pc
                    jsr indirect
                    jsr indirect
                    jmp step_next
                    
do_rts              pla
                    adc #0
                    sta acc2
                    pla
                    adc #0
                    sta acc2 + 1
                    jmp step_next
                    
do_rti              pla
                    sta reg_p
                    clc
                    bcc do_rts
                    
do_branch           lda stack + 12
                    sta acc1 + 1
                    lda #$04
                    sta stack + 12
                    jmp step_execute
                    
ex_or_step          jsr prstr
                    !text "Execute", -1, "or", -1, "step", -1, "(E/S)", -1, "?", -1, 0
                    sty ptr0
                    sty ptr0 + 1
-                   jsr osrdch
                    jsr check_escape
                    and #case_mask
                    cmp #'S'
                    beq +
                    cmp #'E'
                    bne -
+                   jsr oswrch
                    cmp #'S'
                    php
                    jsr newline
                    plp
                    rts
                    
indirect            jsr read_rom
                    pha
                    jsr read_rom
                    sta acc2 + 1
                    pla
                    sta acc2
                    rts
                    
next_pc             lda acc0
                    clc
                    adc #1
                    sta acc2
                    lda acc0 + 1
                    adc #0
                    sta acc2 + 1
                    rts
                    
branched            jsr save_regs
                    lda acc1
                    pha
                    plp
                    ldx #0
                    lda acc1 + 1
                    bpl +
                    dex
+                   clc
                    adc acc2
                    sta acc2
                    txa
                    adc acc2 + 1
                    sta acc2 + 1
                    jmp step_next
                    
stepped             jsr save_regs
                    lda acc1
                    pha
                    plp
                    jmp step_next
                    
c_look              jsr eval
                    jsr acc0_to_acc2
                    jsr hex_prefix
                    jsr check_eol
                    ldx cur_rom
                    lda rom_private, x
                    bmi +
                    lda #0
                    tax
                    beq ++
+                   +cmz16 base_addr
                    tax
                    beq ++
                    sec
                    lda base_addr
                    sbc acc2
                    tax
                    lda base_addr + 1
                    sbc acc2 + 1
++                   stx ptr0
                    sta ptr0 + 1

                    ; cursor edit
                    lda #4
                    ldx #1
                    jsr osbyte
look_next           sec
                    lda acc2
                    sta acc0
                    sbc #$28
                    sta acc2
                    lda acc2 + 1
                    sta acc0 + 1
                    sbc #0
                    sta acc2 + 1
--                  +push16 acc2
                    jsr read_rom
                    jsr inst_len
                    sec
                    sbc #$01
                    clc
                    adc acc2
                    sta acc2
                    bcc +
                    inc acc2 + 1
+                   +cmp16 acc2, acc0
                    bcc +++
-                   jsr osrdch
                    bcc +
                    lda #4
                    ldx #0
                    jsr osbyte
                    jmp throw_escape
                    
+                   cmp #key_down
                    beq +
                    cmp #key_up
                    bne -
                    +pop16 acc2
                    lda #11
                    jsr oswrch
                    jsr oswrch
                    jmp ++
                    
+                   pla
                    pla
                    jsr read_rom
                    jsr inst_len
                    sec
                    sbc #1
                    clc
                    clc
                    adc acc2
                    sta acc2
                    bcc ++
                    inc acc2 + 1
++                  +push16 acc2
                    ldx #0
                    stx acc3
                    jsr cursor_off
                    jsr dis_op
                    jsr cursor_on
                    +pop16 acc2
                    jmp look_next
                    
+++                 pla
                    pla
                    jmp --
                    
parse_tracks        jsr skip_space
                    ldx #40
                    cmp #'4'
                    beq +
                    ldx #80
                    cmp #'8'
                    beq +
-                   jsr throw
                    !text $b1, "40 or 80 tracks", 0
+                   jsr getch
                    cmp #'0'
                    bne -
                    txa
                    pha
                    jsr skip_comma
                    pla
                    rts
                    
parse_drive         jsr skip_space
                    pha
                    jsr unget
                    pla
                    cmp #13
                    beq ++
                    jsr eval_byte
                    cmp #4
                    bcc +
                    jmp throw_baddrive
                    
+                   rts
                    
++                  lda #$01
                    sta stack
                    lda #$82
                    jsr osbyte
                    +stxy stack + 3
                    lda #$10
                    sta stack + 1
                    ldy #$01
                    sty stack + 2
                    lda #$06
                    ldx #0
                    lda #$06
                    ldx #0
                    stx stack + 5
                    stx stack + 6
                    stx stack + 7
                    stx stack + 8
                    +push16 acc2
                    jsr osgbpb
                    +pop16 acc2
                    lda stack + 17
                    and #$03
                    rts

empty_disc          !byte $00, $ff, $ff, $ff, $ff, $01, $69, $00
                    !byte $00, $00, $ff, $ff, $ff, $ff, $05, $63
                    !byte $00, $10, $2a, $00, $10, $00, $00, $00
                    !byte $19, $ff, $ff, $03, $5f, $00, $00, $2a 
                    !byte $00, $00, $ff, $ff, $ff, $ff, $04, $4b
                    !byte $00, $00, $22, $00

-                   pla
                    rts
                    
c_form              jsr parse_tracks
                    sta acc2
                    sta acc2 + 1
                    jsr parse_drive
                    pha
                    jsr check_eol
                    lda #$83
                    jsr osbyte
                    sty acc0 + 1
                    stx acc0
                    tya
                    tax
                    inx
                    inx
                    inx
                    jsr ram_warning
                    bcc -
                    ldy #$2b
-                   lda empty_disc, y
                    sta (acc0), y
                    dey
                    bpl -
                    jsr disc_block                    
                    pla
                    ldy #0
                    sta (acc0), y
                    ldy #$09
                    sta (acc0), y
                    ldy #$16
                    sta (acc0), y
                    ldy #$21
                    sta (acc0), y
                    ldx acc0
                    ldy acc0 + 1
                    lda #$7f
                    jsr osword
                    +mov16z acc1
--                  ldy #$03
-                   jsr wrap_sector
                    dey
                    bne -
                    lda acc1
                    jsr hexbyte
                    jsr prstr
                    !text -2, 0
                    ldy #$59
                    ldx #$0a
-                   lda #$01
                    sta (acc0), y
                    dey
                    txa
                    pha
                    jsr wrap_sector
                    sta (acc0), y
                    dey
                    pla
                    tax
                    lda #0
                    sta (acc0), y
                    dey
                    lda acc1
                    sta (acc0), y
                    dey
                    dex
                    bne -
                    ldy #$0a
                    lda acc0
                    clc
                    adc #$32
                    sta (acc0), y
                    iny
                    lda acc0 + 1
                    adc #0
                    sta (acc0), y
                    ldy #$10
                    lda acc1
                    sta (acc0), y
                    lda acc0
                    clc
                    adc #$09
                    tax
                    lda acc0 + 1
                    adc #0
                    tay
                    lda #$7f
                    jsr osword
                    ldy #$15
                    lda (acc0), y
                    beq +
                    jsr throw
                    ; "Format error"
                    !text $b2, "Format error", 0
+                   ldy #$1d
                    lda acc1
                    sta (acc0), y
                    lda acc0
                    clc
                    adc #$16
                    tax
                    lda acc0 + 1
                    adc #0
                    tay
                    lda #$7f
                    jsr osword
                    ldy #$20
                    lda (acc0), y
                    beq +
                    jsr throw
                    ; "Verify error"
                    !text $b3, "Verify error", 0
+                   inc acc1
                    lda acc1
                    cmp acc2
                    bcs +
                    jmp --
                    
+                   ldy acc0
                    sty ptr0
                    ldx acc0 + 1
                    inx
                    stx ptr0 + 1
                    ldy #0
                    tya
-                   sta (ptr0), y
                    iny
                    bne -
                    inc ptr0 + 1
-                   sta (ptr0), y
                    iny
                    bne -
                    sty acc2 + 1
                    lda acc2
                    asl
                    pha
                    asl
                    rol acc2 + 1
                    asl
                    rol acc2 + 1
                    sta acc2
                    pla
                    adc acc2
                    sta acc2
                    bcc +
                    inc acc2 + 1
+                   ldy #$07
                    lda acc2
                    sta (ptr0), y
                    dey
                    lda acc2 + 1
                    sta (ptr0), y
                    ldy #$22
                    lda ptr0
                    sta (acc0), y
                    iny
                    ldx ptr0 + 1
                    dex
                    txa
                    sta (acc0), y
                    lda acc0
                    clc
                    adc #$21
                    tax
                    lda acc0 + 1
                    adc #0
                    tay
                    lda #$7f
                    jmp osword
                    
disc_block          lda #$82
                    jsr osbyte
                    +stxy ptr0
                    ldx #0
-                   ldy disc_offsets, x
                    lda ptr0
                    sta (acc0), y
                    iny
                    lda ptr0 + 1
                    sta (acc0), y
                    inx
                    cpx #disc_offsets_end - disc_offsets
                    bcc -
                    rts

disc_offsets        !byte $03, $0c, $19, $24 
disc_offsets_end

wrap_sector         ldx acc1 + 1
                    dex
                    bpl +
                    ldx #9
+                   txa
                    stx acc1 + 1
                    rts
                    
parse_track_drive   lda #0
                    sta acc0 + 1
                    sta acc2
                    jsr eval_byte
                    sta acc0
                    jsr skip_comma
                    jsr parse_drive
                    sta acc2
                    jsr check_eol
                    lda acc2
                    ldx #$2a
                    rts
                    
c_get               jsr parse_track_drive
                    ldy #$53
                    bne +
c_put               jsr parse_track_drive
                    ldy #$4b
+                   jsr get_put_parms
                    jsr osword
                    jsr prstr
                    !text "I/O", -1, "result", -1, "=", -1, 0

                    lda stack + 10
                    sta acc0
                    sty acc0 + 1
                    ldx #0
                    lda #10
                    jsr radix_out
                    jmp newline
                    
c_mode              jsr eval_byte
                    tax
                    jsr check_eol
                    cpx #8
                    bcc +
                    jsr throw
                    !text 25, "Bad MODE", 0
+                   lda #22
                    jsr oswrch
                    txa
                    jmp oswrch
                    
c_vdu               ldx #0
                    stx ptr0
                    inx
                    stx ptr0 + 1
                    jsr parse_bytes
-                   dex
                    bmi +
                    lda stack, y
                    jsr oswrch
                    iny
                    bne -
+                   rts
                    
c_same              jsr eval
                    jsr acc0_to_acc2
                    jsr eval
                    +mov16 acc3, acc0
                    jsr eval
                    jsr check_eol
-                   lda (acc3), y
                    cmp (acc2), y
                    beq +
                    ldx #acc2
                    jsr pr_membyte
                    ldx #acc3
                    jsr pr_membyte
                    jsr newline
+                   iny
                    bne +
                    inc acc3 + 1
                    inc acc2 + 1
+                   +dec16 acc0
                    +cmz16 acc0
                    bne -
                    rts
                    
pr_membyte          lda #'('
                    jsr oswrch
                    clc
                    tya
                    pha
                    adc 0, x
                    sta ptr0
                    lda 1, x
                    adc #0
                    sta ptr0 + 1
                    jsr hexbyte
                    lda ptr0
                    jsr hexbyte
                    lda #')'
                    jsr oswrch
                    lda #'='
                    jsr oswrch
                    ldy #0
                    lda (ptr0), y
                    jsr hexbyte_space
                    pla
                    tay
                    rts
                    
pr_sym16            tya
                    pha
                    txa
                    pha
                    +push16 0
                    +push16 2
                    +mov16i 0, symtab
                    jsr read_rom
                    sta $02
                    jsr read_rom
                    sta $03
                    ldy #0
--                  lda (0), y
                    cmp $02
                    bne +
                    iny
                    lda (0), y
                    cmp $03
                    bne pr_sym_copy
                    iny
-                   lda (0), y
                    pha
                    iny
                    and #$7f
                    jsr oswrch
                    pla
                    bpl -
                    bmi ++
+                   iny
pr_sym_copy         iny
                    lda (0), y
                    bpl pr_sym_copy
                    iny
                    tya
                    clc
                    adc 0
                    sta 0
                    bcc +
                    inc $01
+                   ldy #$01
                    lda (0), y
                    dey
                    ora (0), y
                    bne --
                    lda hex_pfx
                    jsr oswrch
                    lda $03
                    jsr hexbyte
                    lda $02
                    jsr hexbyte
++                  +pop16 2
                    +pop16 0
                    pla
                    tax
                    pla
                    tay
                    rts
                    
symtab              !word oswrch 
                    !text "OSWRC", 'H' + $80
                    !word osrdch 
                    !text "OSRDC", 'H' + $80
                    !word osnewl 
                    !text "OSNEW", 'L' + $80
                    !word osasci 
                    !text "OSASC", 'I' + $80
                    !word $ffc2 
                    !text "GSINI", 'T' + $80
                    !word $ffc5 
                    !text "GSREA", 'D' + $80
                    !word $ffb9 
                    !text "OSRDR", 'M' + $80
                    !word $ffbf 
                    !text "OSEVE", 'N' + $80
                    !word oscli 
                    !text "OSCL", 'I' + $80
                    !word osbyte 
                    !text "OSBYT", 'E' + $80
                    !word osword 
                    !text "OSWOR", 'D' + $80
                    !word osfind 
                    !text "OSFIN", 'D' + $80
                    !word osgbpb 
                    !text "OSGBP", 'B' + $80
                    !word osbput 
                    !text "OSBPU", 'T' + $80
                    !word osbget 
                    !text "OSBGE", 'T' + $80
                    !word osargs 
                    !text "OSARG", 'S' + $80
                    !word osfile 
                    !text "OSFIL", 'E' + $80
                    !word brkv 
                    !text "brk", 'v' + $80
                    !word $0203 
                    !text "brkv+", '1' + $80
                    !word wrchv 
                    !text "wrch", 'v' + $80
                    !word wrchv + 1
                    !text "wrchv+", '1' + $80
                    !word rdchv 
                    !text "rdch", 'v' + $80
                    !word rdchv + 1
                    !text "rdchv+", '1' + $80
                    !word stack 
                    !text "stac", 'k' + $80
                    !word rom_language 
                    !text "lan", 'g' + $80
                    !word rom_service 
                    !text "serv", 'e' + $80
                    !word 0 

credits             !text "(C) Andrew Armstrong 1984. Thanks to Nigel, Joe and all at HCCS."
                    !text "Version 1.60 12.2.1984"

                    ; Pad with spaces to next 8k boundary
                    !align $1fff, 0, ' '
